程序使用某个类时经过流程
1.类的加载
    将class文件读入内存，并为之创建一个java.lang.Class对象
    任何类被使用时，系统都会为之简历一个java.lang.Class对象
2.类的连接
    验证阶段：检验被加载的类是否有正确的内部结构，并和其它的类协调一致
    准备阶段：负责为类的白能量分配内存，被设置默认初始化的值
    解析阶段：将类的二进制数据中的符号引用替换为直接引用
3.类的初始化（对类的变量初始化）
    假如类未被加载和连接，则程序先加载并连接该类
    假如该类的直接类父类未被初始化，则先初始化其直接父类
    假如类中有初始化语句，则系统一次执行这些初始化语句
类的初始化时机（首次进行下次操作，当一个类被加载入虚拟机就不会再次载入）
    创建类的实例
    调用类的方法
    访问类或者接口的类变量，或者为该类的变量赋值
    使用反射方式来强制创建某个类或接口对应的java.lang.Class
    初始化某个类的子类
    直接使用java.exe命令来运行某个主类
类加载器
    作用：负责将.class文件加载到内存中，并为之生成对应的java.lang.Class对象
JVM的类加载机制
    全盘负责：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其它Class也将由该类加载负责载入，除非显示使用另外一个类加载器来载入
    父类委托：当一个类加载器负责加载某个Class时，先让父类加载器试图加载该Class,当父类加载器无法加载该类时菜场是从自己的类路径中加载该类
    缓存机制：保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜索该Class,只有当缓存区中不存在该Class对象时，
        系统才会读取该类对应的二进制数据，并将其转换为Class对象，存储到缓存区
ClassLoader是负责加载类的对象，Java运行时具有以下内置类加载器(Run-time Built-in Class Loaders )：
    Bootstrap类加载器:它是虚拟机的内置类加载器，通常表示为null ，并且没有父级。
    Platform class loader 平台类加载器:可以看到所有平台类 ，它们可以用作ClassLoader实例的父ClassLoader 。
        平台类包括Java SE平台API，它们的实现类以及由平台类加载器或其祖先定义的特定于JDK的运行时类。
        #为了允许升级/覆盖定义到平台类加载器的模块，并且升级后的模块读取定义到除平台类加载器及其祖先之外的类加载器的模块，那么平台类加载器可能必须委托给其他类加载器，
        例如，应用程序类加载器 换句话说，平台类加载器可以看到定义到除平台类加载器及其祖先之外的类加载器的命名模块中的类。
    System class loader 应用程序类加载器:与平台类加载器不同。 系统类加载器通常用于在应用程序类路径，模块路径和JDK特定工具上定义类。
        平台类加载器是系统类加载器的父级或祖先，所有平台类都是可见的。
    Bootstrap<-System class loader<- Platform class loader 父<-子
    通常，Java虚拟机以与平台相关的方式从本地文件系统加载类。 但是，某些类可能不是源自文件; 它们可能来自其他来源，例如网络，或者它们可以由应用程序构建。
        方法defineClass将字节数组转换为类类的实例。 可以使用Class.newInstance创建此新定义的类的实例
